const typographyConfig = require('./../src/config/typography.config');
const fs = require('fs');

// Creating typography.scss
async function createTypographyScss() {
  let content = `$typography: (`;

  for (let i = 0; i < typographyConfig.length; i++) {
    const properties = typographyConfig[i].properties;

    if (typographyConfig[i].altLabels != undefined) {
      for (let k = 0; k < typographyConfig[i].altLabels.length; k++) {
        content += addClass(typographyConfig[i].altLabels[k], properties, i);
      }
    }

    content += addClass(typographyConfig[i].name, properties, i);
  }

  content += '\n);';

  const template =
    `// THIS FILE IS GENERATED BY GULP, DO NOT CHANGE THIS TYPOGRAPHY LIST MANUALLY.
// MAKE CHANGES TO TYPOGRAPHY VARIABLES IN TYPOGRAPHY.TEMPLATE.SCSS and TYPOGRAPHY.CONFIG.JS

` + fs.readFileSync('./src/templates/typography.template.scss').toString();
  const newContent = template.replace('//[[INJECT_TYPOGRAPHY_VARIABLES]]', content);
  fs.writeFileSync('./src/variables/typography.scss', newContent);

  return true;
}

function addClass(className, properties, i) {
  let newClass = ``;
  newClass += `
  ${className}: (`;
  for (let j = 0; j < properties.length; j++) {
    if (properties[j].key === 'family') {
      newClass += `
    ${properties[j].key}: #{${properties[j].value},\n    Verdana},`;
    } else {
      newClass += `
    ${properties[j].key}: #{${properties[j].value}},`;
    }
  }
  if (i < typographyConfig.length) {
    newClass += '\n  ),';
  } else {
    newClass += ')\n';
  }
  return newClass;
}

exports.createTypographyScss = createTypographyScss;
