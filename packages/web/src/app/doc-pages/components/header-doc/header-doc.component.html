<!--HEADER-->
<app-component-header [figmaUrl]="figmaUrl" [lastUpdated]="componentData.changelog[0].date">
  <ng-container ngProjectAs="headerTitle">Header</ng-container>
  <ng-container ngProjectAs="headerDescription">
    {{ description }}
  </ng-container>
</app-component-header>

<!--BODY-->
<div class="page-body e-mt-72">
  <!--CEG-->
  <app-component-example-generator [componentData]="componentData"></app-component-example-generator>

  <!-- USAGE -->
  <app-component-section [sectionTitle]="'Usage'">
    <ng-container ngProjectAs="sectionContent">
      <app-component-subsection sectionTitle="The internal header">
        <ng-container ngProjectAs="sectionContent">
          The internal header contains a general top menu and a side navigation section. The navigation bar on
          the side contain app-specific tabs, while the top menu gathers general navigation, such as the app
          switch and any global settings.
        </ng-container>
      </app-component-subsection>
      <app-component-subsection sectionTitle="Sidenav items">
        <ng-container ngProjectAs="sectionContent">
          Since routing usually is performed by a framework-specific library, the DOM for the sidenav items is
          written in your app. This enables use of routing-library features, such as setting active sidenav
          item and changing icon between colored and grayscale if desired. See the examples in the CEG on how
          the DOM structure should be like.
        </ng-container>
      </app-component-subsection>
      <app-component-subsection sectionTitle="Active sidenav item">
        <ng-container ngProjectAs="sectionContent">
          The active state of sidenav items can be toggled with the CSS class
          <span class="code-text no-wrap">e-sidenav__item--active</span>
          and should be added to the link element that already has the class
          <span class="code-text no-wrap">e-sidenav__item</span>
          . The toggle of the active class depends on your framework or routing library, but most modern
          routing libraries has an attribute for setting an active class on routes (see for example
          <a
            rel="noopener"
            class="e-link e-link--inline"
            href="https://angular.io/api/router/RouterLinkActive"
            target="_blank"
          >
            routerLinkActive
          </a>
          for Angular or
          <a
            rel="noopener"
            class="e-link e-link--inline"
            href="https://router.vuejs.org/api/interfaces/routerlinkprops.html#activeclass"
            target="_blank"
          >
            activeClass
          </a>
          for Vue).
        </ng-container>
      </app-component-subsection>
    </ng-container>
  </app-component-section>

  <!--INSTALLATION-->
  <app-component-section [sectionTitle]="'Installation'">
    <ng-container ngProjectAs="sectionContent">
      <app-component-installation [componentData]="componentData"></app-component-installation>
    </ng-container>
  </app-component-section>

  <!--PROPERTIES-->
  <app-component-section [sectionTitle]="'Properties'">
    <ng-container ngProjectAs="sectionContent">
      <app-component-properties-table [componentData]="componentData"></app-component-properties-table>
    </ng-container>
  </app-component-section>

  <!--CHANGELOG-->
  <app-component-section [sectionTitle]="'Changelog'">
    <ng-container ngProjectAs="sectionContent">
      <app-component-changelog [changelog]="componentData.changelog"></app-component-changelog>
    </ng-container>
  </app-component-section>
</div>
